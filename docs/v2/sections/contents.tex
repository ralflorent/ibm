% Virtual Environment for Individual-Based Modeling - Part II
%
% Advanced Project II - Jacobs University Bremen
% Supervisor: Dr. Stefan Kettemann
%
% Created on January 10, 2019
%
% Authors:
%   Ralph Florent <r.florent@jacobs-university.de>
%   Davi Tavares <davi.tavares@leibniz-zmt.de>
%   Agostino Merico <a.merico@jacobs-university.de>
%
% - Overview
% - Features
% - Methods (Procedure)
% - Results, Discussions
% - Conclusion
% - References

% ==============================================================================
% START: Methods, Results, Discussions, Conclusion
% ==============================================================================
\section{Additional Features}\label{sec:features}
As discussed in previous sections, the first part of the project leaves a lot of rooms for improvement. As a matter of fact, that is the reason why we have decided to come up with additional features and augment the functional capabilities for both end-users and developers. Thus, we introduce in the section the set of chosen features and their importance across the application.

For the second version of the project, we have selected carefully  a set of features to gradually integrate into the first version as we maintain the same workflow scheme (see Figure \ref{fig:workflow-scheme}). These additional features are:
\begin{enumerate}
    \item \textit{File structure}
    \item \textit{More types of agents}
    \item \textit{Multiple-agent updates per processing unit}
    \item \textit{Dynamical environment.}
\end{enumerate}

\noindent
Next, we detail each one of them and their importance for the project.

\subsection{A new file structure}
Though it should not be seen as a proper\footnote{Obviously, there are many definitions of a software feature, however, this action seems more like a refactoring than a new capability to the project. Proposing a new approach for file organization is yet questionable as it does not represent a distinguishable characteristic/capability of the project.} feature for the project, yet it remains an essential factor for the refactoring of the code implementation. Renewing the file structure of the project is the first step considered before anything.

Recall that the first code implementation was done in a single Python file (basically, a Jupyter Notebook). The implementation itself was good because it follows a standard programming workflow, which implies that the code should be at least \textit{architected, standardized, structured, scalable, collaborative, documented}, and so forth \cite{rflorent2019veibm1, smashingmagazine}. However, that is not the best approach to keep up as we are adding more features and therefore increasing the degree of complexity of the project. With that being said, restructuring the file organization by breaking the main code into small chunks of code plays an important role in the project maintenance and scalability. The open source community names this decision: \say{a near-term view of implementation and a long-term vision}. Observe in the scheme below the compliant's folder and the new file structure used for the current implementation.

\input{sections/file-struct}

\noindent
Being out of the scope of this document, we will not discuss here other related topics such as \textit{file structure convention, file naming, single responsibility principle}, among others. These topics are quite engaging and require further readings. Please feel free to refer to the \emph{Coding Style Guide} for Python programming at \href{https://www.python.org/dev/peps/pep-0008/}{python.org/dev/peps/pep-0008} or \href{http://google.github.io/styleguide/pyguide.html}{google.github.io/styleguide/pyguide.html} for more details.

Note that, besides the file structure, we also follow an application structure commonly called LIFT:
\begin{itemize}
    \item L: locate quickly the code
    \item I: identify the code at a glance
    \item F: keep the flattest structure possible
    \item T: try to be DRY | Don't Repeat Yourself \textit{(avoid being so DRY that it sacrifices readability).}
\end{itemize}
\noindent
Needless to say, having a good file structure along with a LIFT structure makes the project more robust and undoubtedly scalable. Now that we have a clear understanding of the file structure, let us see how we integrate the actual features with it.

\subsection{More than 2 types of agents}
In the previous version of the project, we hardcoded two (2) types of agents: \emph{short-legged} and \emph{long-legged} waterbirds. Recall as we discussed in Section \ref{sec:overview} that in the real world there are more than just two categories of waterbirds. This short- and long-legged way of categorizing the agents was a simple approach as we intend to firstly create a pilot test and then built upon it something more complex. So, based on the assumption that the belly of birds cannot touch the water because it would contradict the homeostasis theory\footnote{Birds would lose temperature rapidly.}, we involve a set of four (4) bird species, with legs sizes of 5 cm (small shorebirds), 10 cm (big shore birds), 30 cm (small herons) and 60 cm (big herons). As for their virtual representation in the VE, we discuss the implementation in Section \ref{sec:methodology}.

\subsection{Multiple-agent updates per processing unit}
Going a bit more technical, the previous implementation was lacking the functional capability of processing all the agents separately for a single update. That is to say, for $n$ processing times, only $n$ agents were randomly selected and processed\footnote{Processed: update an agent geometric position if the criteria for moving it were met.} with possibility of replacement. For instance, in a setting of 10 agents and 5 processing times, it is possible that the same exact bird gets selected and processed 5 times.

This new feature, \emph{Multiple-agent updates per processing unit}, refers to adding the capability of processing every single agent for every processing unit.

\noindent
\textbf{Important}: \textit{Be aware that we use the term \emph{process} in lieu of \emph{update} when referring to moving an agent randomly to another position. There is a little nuance and we want to keep a clear cut. It occurs that the term \emph{process} is more global and avoids the confusion that will always move. As a matter of fact, process means to try to update. An agent will move if and only if the conditions for moving to another place are met.}

\subsection{Make the environment more dynamical}
Finally, we opt for using a dynamical environment, that is, by varying certain characteristics of the environment. One of the most relevant environmental factors in the VE setting is the water depth. By tweaking this parameter, we can simulate environmental changes (not in the VE though) over time and observe how the waterbirds evolve with those changes. Why? Because in real-life situations, the waterbirds' interactions and evolution are highly correlated to environmental changes.

Simulating an environment change within the virtual environment is a bit tricky and requires to tweak some variables to obtain the desired results. So, we provide more details on this specific case scenario in Section \ref{sec:methodology}.

% \subsection{Data tracking for sensitivity analysis}

\section{Methodology}\label{sec:methodology}
The methods used in the first version are still applicable for this version of the project, with the exception of employing some key changes without losing the main focus. So, we describe in the following section what has been changed and how these changes were implemented.

\subsection{The application}
What is happening now when the application runs? Recall the workflow scheme in Figure \ref{fig:workflow-scheme} that indicates the three (3) main steps \textit{Initialize, Observe, Update} used in the first part VE simulation. The idea is still the same, except that we include now more internal processes. As illustrated in line number \emph{3} of Listing \ref{lst:app}, the core methods imported to operate the simulation are exactly the same. In other words, the application runs and does the following:
\begin{itemize}
    \item first, initializes some internal configurations (we detail more about it later)
    \item next, creates $m$ number of habitats and $n$ number of agents
    \item then, snapshots the current state of the environment
    \item finally, runs the update process per time unit $t$.
\end{itemize}

\noindent
We omit for now the \emph{post-condition} operations (scripts) since they are not part of the main idea but simply helper functionalities for future analyses.

\subsection{External configuration}
Although it implies the utilization of intensive programming to implement it, we proceed this time by adding a configuration file to load the external setup for the program to run. The two files in charge of such a task are \emph{config.yml} and \emph{config.py} and are located under the \emph{src/notebooks} folder. For best practice and for human-readability reasons \cite{mthoma2014cfgyml}, the \emph{config.yml} file is used, among other suitable options, to pass an application profile along with the parameters required by the system to operate. The profile is useful for meta operations like file system handling, for example, whereas the parameters are a way to load the core values such habitat and/or agent information for the simulation. For example, loading dynamically the types of agents is made quite practical with the external setup. That is, an array of agents with the format shown below is expected and will be internally handled and represented as-is in the virtual environment.
\begin{minted}
    [
        baselinestretch=1.2,
        bgcolor=bg-mint,
        fontsize=\footnotesize,
    ]
    {yaml}
agents:
    - type: 30cm # unique identifier to categorize an agent
    quantity: 7  # total of agents of this kind to create
    color: '#7C79A2' # color representation of this type of agent
    label: 30cm-legged # descriptive label for the plots
    fn: # runnable function (definition, dependencies, arguments)
        def: 'lambda x: -10.89 * math.log(x) + 44.71'
        deps:
            - 'import math'
        args:
            - x
    habs: # types of habitats allowed for use
        - 1
        - 2
\end{minted}

On the other hand, the \emph{config.py} file is applied to load the main configuration in memory and apply it when it is necessary. The file serves also as basis to set some constants values as they are frequently used across the application.

\begin{listing}[H]
    \inputminted
    [
        baselinestretch=1.2, % interspace size
        bgcolor=bg-mint,
        fontsize=\footnotesize,
        linenos % show line numbers
    ]
    {python}{scripts/app.py}
    \caption{Main entry point of the application}
    \label{lst:app}
\end{listing}

\subsection{File system handling}
The initial setup involves additional settings besides loading the external configuration. These settings are the file system handling, the operating system check, and the python environment (kernel). They help to prepare a sanitized workspace to run the application without crossing some surprising exceptions at the time of execution.

The application is made smart enough to create, remove, and check the existence of files within the scope of the project. The folders \emph{samples} and \emph{graphs} are used for this purpose and contain respectively snapshots and plots files. Keep in mind that for the file system handling, certain use cases (e.g., user permissions) are considered.

\subsection{The constants}
The constants are useful when it comes to avoiding magic strings and numbers. As mentioned before, the loaded configuration is part of the constants used throughout the application. Besides that, we use constants for core elements (e.g., key identifier for the static habitats), directory and file paths, in-memory storage, and default values.

\subsection{The helpers}
As we mention in previous sections, the core functionalities \emph{Initialize, Observe, Update} include some internal operations. For reusability reasons, we use helper functions to handle these operations such as random points generation, euclidean distance, gif maker, and so on.

\subsection{The \emph{Update} algorithm}


\section{Results \& Discussions}

\section{Conclusion}
% ==============================================================================
% END: Methods, Results, Discussions, Conclusion
% ==============================================================================